# Code architecture

<!-- mention semantics and paper citations -->

As an overview, the program does three things: 
1. It takes sentences inputted by the user, translates them into constraints on Z3 BitVectors.
2. Finds a model that solves the constraints.
3. Draws on the model to interpret the original sentences provided by the user.


## Generating Z3 Constraints

A set of premises, set conclusions, and BitVector length N are passed to `make_model_for` which calls `prefix` from the `syntax` module.
This converts the premises and conclusions from strings in infix notation to lists in prefix notation conforming to the following rules:
  - An atomic input sentence `'A'` is converted to `[A]` in prefix notation, where `A` is declared as a Z3 sort called `AtomSort`.
  - The designated top element `'top'` is an `AtomSort` but treated separately by the semantics.
  - An atomic input sentence `'unary_operator A'` is `['unary_operator', prefix(A)]`, where `prefix(A)` represents the prefix form of `A`. If `A` is atomic, `'unary_operator A'` is `['unary_operator', [A]]`, where `A` in the embedded list is an AtomSort.
  - An atomic sentence `'A binary_operator B'` is `['binary_operator', prefix(A), prefix(B)]`.
For instance, if `A` and `B` are both atomic, `'A binary_operator B'` is `['binary_operator', [A], [B]]`, where the `A` and `B` in the embedded lists are AtomSorts.
This ensures that every prefix sentence is an instance of the python list class, and if the length of that list is larger than one, then the first element is the main operator of the sentence (as a string). This allows recursive functions to call the appropriate semantic clauses and to access the contents of the sentences.[^note_on_backslashes]

[^note_on_backslashes]: Trivially, the function `add_backslashes_to_infix` adds two backslashes to every operator and the special `top` sentence so that when print they will be LaTeX commands. Two backslashes are necessary because `'\'` is a special character in python so one instance next to e.g. `'neg'` will not print `'\neg'` but rather `'eg'` on the next line. This also ensures that, in the options where a user can search for a prefix sentence in a solved model, they can find it regardless of whether they originally inputted it with backslashes or not (and regardless of whether they do so in the search).

Once converted, the prefix premises and conclusions are stored in a `ModelSetup` object.
It is inside `ModelSetup` that the `define_N_semantics` from the `semantics` module is defined, where this includes the following primitives: 
  - `verify` and `falsify` are relations between states and atomic sentences.
  - `possible` a property of states.
  - `assign` is a function from state-sentence pairs to states and is used to Skolemize the exhaustivity constraint discussed in [Semantics](https://github.com/benbrastmckie/ModelChecker/blob/master/Docs/semantics.md).
  - `w` is the designated world at which sentences are evaluated.
The prefix premises and conclusions are then converted into Z3 constraints by requiring each premise to be `true_at` the world `w` and each conclusion to be `false_at` the world `w`.
The `true_at` and `false_at` functions include the semantic clauses for the operators in the language and is discussed in greater detail in [Semantics](https://github.com/benbrastmckie/ModelChecker/blob/master/Docs/semantics.md).

The Z3 constraints that result from the prefix premises and conclusions are then combined with the following general frame constraints:
  - Every fusion of states is a state.
  - Every part of a possible state is possible.
  - The _null state_ `□` which is a part of every state is possible.
A final set of Z3 constraints is generated by requiring each atomic sentence that occurs in the premises and conclusions to satisfy the following:
  - Any fusion of a verifier and falsifier for an atomic sentence is impossible.
  - Every possible state is compatible with either a verifier or falsifier for each atomic sentence.
  - The verifiers (similarly the falsifiers) for an atomic sentence are closed under fusion (though not necessarily possible).
As shown by [Fine 2017](https://link.springer.com/article/10.1007/s10992-016-9413-y), these constraints guarantees that every world state includes a part that either verifies or falsifies each atomic sentence, but not both.
Imposing these constraints amounts to assigning atomic sentences to _hyperintensional proposition_ of the kind motivated and defended in [Brast-McKie 2021](https://link.springer.com/article/10.1007/s10992-021-09612-w).
In contrast to extensional and intensional theories of content, the space of hyperintensional propositions forms a non-interlaced bilattice rather than a Boolean lattice.
This higher resolution theory of content plays a critical role in modeling operators that sensitive to differences in subject-matter and so are capable of tracking relevance as required by explanatory operators.

## The Z3 Solver

Once the Z3 constraints have been generated for a given set of `premises`, `conclusions`, and value `N` of atomic states, these constraints are added to a Z3 solver.
If Z3 finds a model that satisfies all of the constraints, the model is stored in `ModelSetup`.
Otherwise, Z3 will return the unsatisfiable core constraints, storing these in `ModelSetup` instead.

If no model is found, the model checker halts after printing the unsatisfiable core constraints.
If a model is found, the `ModelSetup` object is passed to a `StateSpace` object which extracts the extensions of the primitives `verify`, `falsify`, `possible`, and `w`.
The `model_definitions` module provides a number of definitions which are used to construct and store the following elements:
  - The set of all states.
  - The subset of all possible states.
  - The subset of all world states.
  - The sets of verifier and falsifier states assigned to each atomic sentence.
The definitions used to generate these elements above mirror those used to define Z3 constraints.
However, instead of employing the Z3 logical primitives, these definitions are employ standard methods within Python.
Nevertheless, the underlying logic is the same in both cases, and much more concisely expressed by the Z3 expressions.

The elements extracted from the Z3 model are then used to assign a `Proposition` object to every subsentence of the premises and conclusions.
Each `Proposition` object includes the following attributes:
  - A sentence in prefix notation.
  - A set of verifier states.
  - A set of falsifier states.
In order to assign verifier and falsifier states to complex sentences, the following definitions are provided in the `model_definitions` module:
  - `product(A,B)` returns a set consisting of `fusion(x,y)` for all `x in A` and `y in B`.
  - `coproduct(A,B)` returns a set consisting of the union of `A`, `B`, and `product(A,B)`.
These definitions play a critical role in identifying complex extensional propositions, mirroring the semantics for the corresponding operators.
Letting `find_complex_proposition(model_setup, Y, world_state) = (Y_V, Y_F)` for ease of exposition, the `find_complex_proposition` function includes the following clauses for negation `neg`, conjunction `wedge`, and disjunction `vee`:
  - `find_complex_proposition(model_setup, ['neg', Y], world_state)` returns the falsifiers `Y_F` followed by the verifiers `Y_V` for `Y`.
  - `find_complex_proposition(model_setup, ['wedge', Y, Z], world_state)` returns the `product(Y_V, Z_V)` of verifiers followed by the `coproduct(Y_F, Z_F)` of falsifiers.
  - `find_complex_proposition(model_setup, ['vee', Y, Z], world_state)` returns the `coproduct(Y_V, Z_V)` of verifiers followed by the `product(Y_F, Z_F)` of falsifiers.
For corresponding details, see the discussion provided in [Semantics](https://github.com/benbrastmckie/ModelChecker/blob/master/Docs/semantics.md).

There are four designated _extremal propositions_ `<{□},∅>`,`<∅,{□}>`,`<S,{■}>`, and `<{■},S>` where `S` is the _set of all states_ and `■` is the _full state_ which is the fusion of all states in `S`.
Of particular importance are the first two extremal propositions which correspond to the bottom element for essence `sqsubseteq` and the bottom element for ground `leq`, respectively.
Letting `find_complex_proposition(Y, world_state) = (Y_V, Y_F)` for ease of exposition, bottom propositions are assigned to constitutive sentences by way of the following:
  - `contained_in(A,B)` returns `True` if every state in the set `A` has a part in the set `B`.
  - `find_complex_proposition(['leq', Y, Z], world_state)` returns `<{□},∅>` _if_ `Y_V <= Z_V` and `product(Y_F, Z_F) <= Z_F` and `contained_in(Z_F, Y_F)`, and returns `<∅,{□}>` otherwise.
  - `find_complex_proposition(['sqsubseteq', Y, Z], world_state)` returns `<{□},∅>` _if_ `product(Y_V, Z_V) <= Z_V` and `contained_in(Z_V, Y_V)` and `Y_F <= Z_F`, and returns `<∅,{□}>` otherwise.
  - `find_complex_proposition(['preceq', Y, Z], world_state)` returns `<{□},∅>` _if_ `product(Y_V, Z_V) <= Z_V` and `product(Y_F, Z_F) <= Z_F`, and returns `<∅,{□}>` otherwise.
  - `find_complex_proposition(['equiv', Y, Z], world_state)` returns `<{□},∅>` _if_ `Y_V == Z_V` and `Y_F == Z_F`, and returns `<∅,{□}>` otherwise.
These definitions mirror the clauses provided in the [Semantics](https://github.com/benbrastmckie/ModelChecker/blob/master/Docs/semantics.md). 
That true constitutive sentences are verified by the null state `□` corresponds to the idea that nothing is required for a true constitutive claim to obtain.

In order to assign propositions to modal and counterfactual sentences, the following functions are defined:
  - `evaluate_modal_expr(model_setup, sentence, eval_world)` returns `True` if `sentence` is true 
  - `evaluate_cf_expr(model_setup, sentence, eval_world)`

The dirty work that remains is to extract that information about how states (so really integers in binary) relate to concepts like "possible", verification, alternate-ness, worldhood, etc. This is done with the `ModelStructure` and `StateSpace` objects in the `model_structure` module. The ModelStructure object is basically an updated bucket, for convenience, that stores everything that's relevant up to now. It's necessary because in case there is not a model, there is not a state space, so it's counterintuitive to make a StateSpace object. So in the case there is no model, `ModelStructure` is the final result. Otherwise, we proceed to make a `StateSpace` object, which takes the previous two buckets to set up a the space of states. Inside it you can find which states are possible, which are worlds, which is the main world of interpretation, the (mathematical) functions `possible`, `verify`, etc. Proposition objects are also made, which are essentially just a place to store the verifiers and falsifiers of every input sentence (and intermediate sentence). The verifiers and falsifiers for extensional sentences are rather straightforward (and follow the definitions in the manuscript); for non-extensional sentences, a true sentence has a verifier of the null state and no falsifiers, and the converse if false. These objects (themselves mini-buckets of information) are themselves stored in the bigger StateSpace bucket. At this point, all of the relevant information has been found from the Z3 constraints and organized—there is now a list of states (i.e. numbers) that are possible, that are worlds, etc. There are a couple interesting/noteworthy things in this process, which is where the final module `model_definitions` comes in. 
1. Since states are integers (BitVectors) and we know which are possible, which verify others, etc, but not which are alternatives, which are verifiers for _specific propositions_, many of the functions in `model_definitions` look awfully similar to functions in `semantics`, like `fusion` and `bit_fusion`, `is_world` and `bit_world`, etc. Since they do the same thing, why can't the same functions be used for both? The reason boils down to how Z3 represents BitVectors. When defining constraints, Z3 uses `BitVec`s—these bitvectors do _not_ have an assigned value yet. When they do, Z3 represents them as `BitVecVals`, which are bitvectors with an associated value. The functions that Z3 uses on these two are slightly different, so we need to have two sets of functions for them: one set when defining constraints, another when extracting information from them.
2. To define Proposition objects, the function `find_complex_proposition` uses the recursive functions in the manuscript defined with products and coproducts to get verifiers and falsifiers for any sentence that exists in the space created by the original inputs (i.e., any possible subsentence or sentence made by combining any of the inputs).
3. (Add more noteworthy stuff here later?)

However, remember how we solved the constraints: in Z3. So everything at this point remains in terms of BitVectors, which are literally just numbers. This is very hard nigh impossible to understand as raw output, so we must translate it back into something that philsophers (or really anyone/thing besides Z3) can understand. 


## Representing Countermodels

We have successfully either found or not found a model for our input sentences! Now we need to translate that into user-readable output. All of the methods for `ModelStructure` and `StateSpace` with "print" in the name do exactly that. They themselves rely on either other methods of these objects or helpers defined in the `model_definitions` module. This step is also where files are made with outputs (with the `print_all` method of `StateSpace`—it itself is an amalgamation of specialized print methods belonging to the StateSpace and ModelSetup of the model). All of this is rather mechanical; an interesting point though, to come full circle, is the function `infix` defined in the `syntax` module: it takes a sentence in prefix notation and returns its infix equivalent. This is used throughout the print methods for human-readable input. Other noteworthy functions in this domain include `pretty_set_print`, which prints python in a nice way. (Add more? I think his covers basically everything. I am also realizing that you've done a lot in this domain @Ben, so maybe you have some insights here.) 
