'''
Attempt 2 at doing class semantics. The first issue that came up was the fact that if we put
operator objects in prefix sentences, we need to have the semantics already defined. But if we
have the semantics already defined, we need to already have the constraints generated by the
operators' "true_at" and "false_at" functions. That was fixed by having a global operator_dict, 
that has operator names as keys and dictionaries with relevant info as values. The second problem
that came up was the same reason that semantics is currently one big function: the possible, 
verify, falsify, and assign functions (and N) would have to be passed in as arguments to everything.
At first I reluctantly started editing functions to do that but realized that makes everything
very unfriendly to the user and is quite tedious to implement. The solution I thought of for now
is (not fully implemented, but this is the idea): a user will make an object called a Frame object
that has all the definitions that do not change from theory to theory. Then they will add to that
object whatever things they want to add re how to define truth and what not by making a subclass
with the same __init__ method and whatever other additional methods they want. Then to add operators,
which is really all that's left at this point, they will add things to the operator_dict of that
Frame object. In this way, the definitions of possible, verify, falsify, and assign (pvfa from now
on) are in the same environment as where they are defining the true_at (and false_at, if bilateral)
method(s) so you don't have to enter pvfa into the method manually, you can access them by inside
the method writing frame.possible (and just pass a frame into the method, which is already done
in the form of self). 

Thought of from the perspective of a user doing all this in a script, the Frame object strategy
allows for broader definitions that operators may depend on to be put in first, then add operators.

Everything after would follow exactly as is in the class semantics doc, with frame information
being accessible to the ModelSetup object by making the Frame object an attribute of the
ModelSetup object or something of that sort. 
'''



from z3 import (
    sat,
    Lambda, # used in FiniteForAll and FiniteExists definitions
    Implies,
    Or,
    Not,
    Solver,
    And,
    BitVec,
    BitVecVal,
    substitute, # used in FiniteForAll definition
    Function,
    BitVecSort,
    BoolSort,

)
from z3 import Exists as Z3Exists
from z3 import ForAll as Z3ForAll
from syntax import AtomSort, prefix
Exists = Z3Exists
ForAll = Z3ForAll

class Frame:
    def __init__(self, N):
        self.N = N
        self.verify = Function("verify", BitVecSort(N), AtomSort, BoolSort())
        self.possible = Function("possible", BitVecSort(N), BoolSort())
        self.operator_dict = {}

    def add_operator(self, operator_name, **kw):
        self.operator_dict[operator_name] = kw

    
class BrastMcKieFrame(Frame):
    def __init__(self, N):
        super().__init__(N)
        self.falsify = Function("falsify", BitVecSort(N), AtomSort, BoolSort())
        self.assign = Function("assign", BitVecSort(N), AtomSort, BitVecSort(N))

    def fusion(self, bit_s, bit_t):
        """the result of taking the maximum for each index in bit_s and bit_t
        returns a Z3 constraint"""
        return bit_s | bit_t

    def is_part_of(self, bit_s, bit_t):
        """the fusion of bit_s and bit_t is identical to bit_t
        returns a Z3 constraint"""
        return self.fusion(bit_s, bit_t) == bit_t

    def non_null_part_of(self, bit_s, bit_t):
        """bit_s verifies atom and is not the null state
        returns a Z3 constraint"""
        return And(Not(bit_s == 0), self.is_part_of(bit_s, bit_t))

    def compatible(self, bit_x, bit_y):
        """the fusion of bit_x and bit_y is possible
        returns a Z3 constraint"""
        return self.possible(self.fusion(bit_x, bit_y))

    def maximal(self, bit_w):
        """bit_w includes all compatible states as parts.
        returns a Z3 constraint"""
        x = BitVec("max_x", N)
        return ForAll(
            x,
            Implies(
                self.compatible(x, bit_w),
                self.is_part_of(x, bit_w),
            ),
        )

    def is_world(self, bit_w):
        """bit_w is both possible and maximal.
        returns a Z3 constraint"""
        return And(
            self.possible(bit_w),
            self.maximal(bit_w),
        )

    def max_compatible_part(self, bit_x, bit_w, bit_y):
        """bit_x is the biggest part of bit_w that is compatible with bit_y.
        returns a Z3 constraint"""
        z = BitVec("max_part", N)
        return And(
            self.is_part_of(bit_x, bit_w),
            self.compatible(bit_x, bit_y),
            ForAll(
                z,
                Implies(
                    And(
                        self.is_part_of(z, bit_w),
                        self.compatible(z, bit_y),
                        self.is_part_of(bit_x, z),
                    ),
                    bit_x == z,
                ),
            ),
        )

    def is_alternative(self, bit_u, bit_y, bit_w):
        """
        bit_u is a world that is the alternative that results from imposing state bit_y on
        world bit_w.
        returns a Z3 constraint
        """
        z = BitVec("alt_z", N)
        return And(
            self.is_world(bit_u),
            self.is_part_of(bit_y, bit_u),
            And(self.is_part_of(z, bit_u), self.max_compatible_part(z, bit_w, bit_y)), # REMOVABLE
        )

    def true_at(self, prefix_sentence, eval_world):
        if len(prefix_sentence) == 1:
                sent = prefix_sentence[0]
                if 'top' not in str(sent)[0]: # top const alr in model, see find_model_constraints
                    x = BitVec("t_atom_x", N)
                    return Exists(x, And(self.is_part_of(x, eval_world), self.verify(x, sent))) # REMOVABLE
        operator = self.operator_dict[prefix_sentence[0]] # operator is a dict, the kw passed into add_operator
        args = prefix_sentence[1:]
        return operator['true_at'](args, eval_world)

    def false_at(self, prefix_sentence, eval_world):
        if len(prefix_sentence) == 1:
            sent = prefix_sentence[0]
            x = BitVec("f_atom_x", N)
            return Exists(x, And(self.is_part_of(x, eval_world), self.falsify(x, sent))) # REMOVABLE
        operator = self.operator_dict[prefix_sentence[0]] # operator is a dict, the kw passed into add_operator
        args = prefix_sentence[1:]
        return operator['false_at'](*args, eval_world)
    
    def frame_constraints(self):
        x = BitVec("frame_x", N)
        y = BitVec("frame_y", N)
        z = BitVec("frame_z", N)
        u = BitVec("frame_u", N)
        frame_constraints = [
            ForAll([x, y], Implies(And(self.possible(y), self.is_part_of(x, y)), self.possible(x))),
            ForAll([x, y], Exists(z, self.fusion(x, y) == z)),
            self.is_world(self.main_world), # w is passed in from the big outer function define_N_semantics
        ]
        return frame_constraints
        



N = 3
frame = BrastMcKieFrame(N)
frame.add_operator('\\neg',
                   true_at=lambda arg, eval_world: frame.false_at(arg, eval_world),
                   false_at=lambda arg, eval_world: frame.true_at(arg, eval_world),
                   arity=1),
frame.add_operator('\\wedge',
                   true_at=lambda X, Y, eval_world: And(frame.true_at(X, eval_world), frame.true_at(Y, eval_world)),
                   false_at=lambda X, Y, eval_world: Or(frame.false_at(X, eval_world), frame.false_at(Y, eval_world)),
                   arity=2)
frame.add_operator('\\vee',
                   true_at=lambda X, Y, eval_world: Or(frame.true_at(X, eval_world), frame.true_at(Y, eval_world)),
                   false_at=lambda X, Y, eval_world: And(frame.false_at(X, eval_world), frame.false_at(Y, eval_world)),
                   arity=2)


class ModelSetup():
    def __init__(self, frame, infix_premises, infix_conclusions):
        self.prefix_premises = [prefix(prem) for prem in infix_premises]
        self.prefix_conclusions = [prefix(con) for con in infix_conclusions]
        prefix_sentences = self.prefix_premises + self.prefix_conclusions
        self.sentence_letters = find_sentence_letters(prefix_sentences)
        self.atom_proposition_constraints = find_prop_constraints(self.sentence_letters, disjoint_props_bool)
        self.frame_constraints = frame.frame_constraints()


















