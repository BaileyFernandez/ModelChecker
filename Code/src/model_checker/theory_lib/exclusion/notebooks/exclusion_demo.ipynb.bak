{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## `model_checker` Python API Jupyter notebook\n",
    "This jupyter notebook will go through the basics of how to use the `model_checker` package from scratch in python. It will also go over how to use some of the built-in features that make exploring semantics already in `theory_lib` much easier. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First, the basic imports. If you want to make a theory from scratch, see the `semantic.py` and `operator.py` files for the theories in `theory_lib`. This notebook will use the semantics for Bernard and Champollion's exclusion semantics (which is what the second import is)."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "source": "# Environment setup for ModelChecker imports\nimport sys\nimport os\nimport importlib\n\n# Add project root to path if needed\nproject_root = None\npossible_roots = [\n    # If notebook is in the repo structure\n    os.path.abspath(os.path.join(os.getcwd(), \"../../../../../\")),\n    os.path.abspath(os.path.join(os.getcwd(), \"../../../../\")),\n    os.path.abspath(os.path.join(os.getcwd(), \"../../../\")),\n    # Common installation paths\n    os.path.expanduser(\"~/Documents/Philosophy/Projects/ModelChecker/Code\"),\n    os.path.expanduser(\"~/ModelChecker/Code\"),\n]\n\nfor path in possible_roots:\n    if os.path.isdir(path) and os.path.isdir(os.path.join(path, \"src\", \"model_checker\")):\n        project_root = path\n        break\n\nif project_root:\n    paths_to_add = [project_root, os.path.join(project_root, \"src\")]\n    for path in paths_to_add:\n        if path not in sys.path:\n            sys.path.insert(0, path)\n    print(f\"Added ModelChecker paths: {paths_to_add}\")\n\n# Now import the packages\nimport model_checker as mc\nfrom model_checker.theory_lib import exclusion\n\n# IMPORTANT: Define operators at the module level for visibility in all cells\nfrom model_checker.syntactic import OperatorCollection\nfrom model_checker.theory_lib.exclusion.operators import (\n    ExclusionOperator, \n    UniAndOperator, \n    UniOrOperator, \n    UniIdentityOperator\n)\noperators = OperatorCollection(\n    ExclusionOperator, \n    UniAndOperator, \n    UniOrOperator,\n    UniIdentityOperator\n)\n\nprint(f\"ModelChecker loaded from: {mc.__file__}\")\nprint(f\"Operators variable defined with {len(operators.operator_dictionary)} operators\")"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": "# Verify we have the operators variable defined\nprint(\"Operators collection contains these operators:\")\nfor op_name in operators.operator_dictionary:\n    print(f\"  - {op_name}\")\n\n# We can also access exclusion.exclusion_operators, but we'll use our manually created operators\ntry:\n    print(\"\\nDefault exclusion operators:\")\n    for op_name in exclusion.operators.exclusion_operators.operator_dictionary:\n        print(f\"  - {op_name}\")\nexcept Exception as e:\n    print(f\"Error accessing exclusion.exclusion_operators: {e}\")",
   "outputs": []
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# This cell is now deprecated - we're using the operators defined in the previous cell\n",
    "# Comment out the older, problematic implementation\n",
    "\n",
    "# # import the default operators of the theory:\n",
    "# # operators = exclusion.exclusion_operators\n",
    "# # assert isinstance(operators, mc.syntactic.OperatorCollection)\n",
    "\n",
    "# # import specific operators manually:\n",
    "# # operators = mc.syntactic.OperatorCollection(exclusion.operators.ExclusionOperator, # Negation\n",
    "# #                                             exclusion.operators.UniAndOperator, # And\n",
    "# #                                             exclusion.operators.UniOrOperator, # Or\n",
    "# #                                             exclusion.operators.UniIdentityOperator # Propositional Identity\n",
    "# #                                             )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": "# Verify operators are accessible and then iterate through them\nif 'operators' in globals():\n    print(\"Operators are accessible\")\n    for operator in operators:\n        print(operator) # hopefully it's clear which operators correspond to which!\nelse:\n    print(\"ERROR: operators variable is not defined in this scope\")\n    # Re-import operators if not available\n    from model_checker.syntactic import OperatorCollection\n    from model_checker.theory_lib.exclusion.operators import (\n        ExclusionOperator, \n        UniAndOperator, \n        UniOrOperator, \n        UniIdentityOperator\n    )\n    operators = OperatorCollection(\n        ExclusionOperator, \n        UniAndOperator, \n        UniOrOperator,\n        UniIdentityOperator\n    )\n    print(f\"Re-created operators with {len(operators.operator_dictionary)} operators\")\n    for operator in operators:\n        print(operator)",
   "outputs": []
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "source": "# Define premises and conclusions using raw strings for proper backslash handling\n# Make sure to wrap binary operations in parentheses\npremises = [r\"\\exclude (P \\uniwedge Q)\"]\nconclusions = [r\"(\\exclude P \\univee \\exclude Q)\"]\n\n# Make sure operators is defined and accessible\nif 'operators' not in globals():\n    print(\"ERROR: operators variable still not defined, recreating\")\n    from model_checker.syntactic import OperatorCollection\n    from model_checker.theory_lib.exclusion.operators import (\n        ExclusionOperator, \n        UniAndOperator, \n        UniOrOperator, \n        UniIdentityOperator\n    )\n    operators = OperatorCollection(\n        ExclusionOperator, \n        UniAndOperator, \n        UniOrOperator,\n        UniIdentityOperator\n    )\n\n# Now create the syntax object\nsyntax = mc.syntactic.Syntax(premises, conclusions, operators)\nprint(\"Syntax object created successfully\")"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": "# Remove the old cell that used exclusion_operators which is not defined\n# Instead use our properly defined operators from previous cells\n\n# This cell was previously:\n# premises = [\"\\\\exclude (P \\\\uniwedge Q)\"]\n# conclusions = [\"(\\\\exclude P \\\\univee \\\\exclude Q)\"]\n# syntax = mc.syntactic.Syntax(premises, conclusions, exclusion_operators)\n\n# We've already set this up correctly in the previous cell\nprint(\"Using syntax with these premises and conclusions:\")\nprint(f\"  Premises: {premises}\")\nprint(f\"  Conclusions: {conclusions}\")",
   "outputs": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "premises = [\"\\\\exclude (P \\\\uniwedge Q)\"]\n",
    "conclusions = [\"(\\\\exclude P \\\\univee \\\\exclude Q)\"]\n",
    "syntax = mc.syntactic.Syntax(premises, conclusions, operators)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we make the semantics. We will just use the one in the `theory_lib` for exclusion semantics. A `Semantics` object, of which `ExclusionSemantics` is an instance, has limited user-useful attributes, which are shown below. For more details, see the `SemanticDefaults` class of the `model.py` module of `model_checker` and the `[X]Semantics` object found in the `semantic.py` module of the theory you are interested in. To initialize as a `Semantics` object, feed it the number of atomic states you want in your model. We represent this value with `N`. [UPDATE: This has changed. Now you feed it the settings you want the semantics to have. We will just use the theory's default settings for ease. ]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# N = 3 # number of atomics tates desired\n",
    "default_settings = exclusion.ExclusionSemantics.DEFAULT_EXAMPLE_SETTINGS\n",
    "print(default_settings)\n",
    "semantics = exclusion.ExclusionSemantics(default_settings)\n",
    "print(str(semantics))\n",
    "print(semantics.N) # number of atomic states in the model\n",
    "# print(semantics.DEFAULT_EXAMPLE_SETTINGS) # default settings. Will be useful in next step. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The last ingredient we need before we get the ball rolling is a `Proposition` class. As with the semantics there is a default for the exclusion semantics in its module; for details on how to make one from the ground up, see the `PropositionDefaults` class in the `model.py` module of `model_checker` and the `[X]Proposition` object in the `semantic.py` modules of the theories in `theory_lib`. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "proposition_class = exclusion.UnilateralProposition"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now that we have a syntax with a specific example, a semantics, and a definition of a proposition, we can in principle find all the constraints that would be needed to see if a countermodel exists. And indeed this is what we do next, by defining a `ModelConstraints` object. Since we can impose additional constraints on the model (e.g., only contingent sentences, only non-empty verifiers, only non-null falsifiers), we also pass a `settings` dictionary into the `ModelConstraints` object. The `ExclusionSemantics` has a default setting dictionary, which was printed in the cell above; we will use this for now. \n",
    "\n",
    "A `Model_Constraints` object has many user-useful attributes, mainly in the form of Z3 constraints. Z3's constraints are in prefix notation; also for more details see the specific implementations of constraints in the `Semantics` object and `Proposition` object you have. "
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "source": "# Create settings dictionary with required keys to avoid missing key errors\nsettings = semantics.DEFAULT_EXAMPLE_SETTINGS.copy()  # Start with default settings\n\n# Add default general settings if they don't exist\nDEFAULT_GENERAL_SETTINGS = {\n    \"print_impossible\": False,\n    \"print_constraints\": False,\n    \"print_z3\": False,\n    \"save_output\": False,\n    \"maximize\": False,\n}\n\n# Update settings with general settings\nfor key in DEFAULT_GENERAL_SETTINGS:\n    settings[key] = DEFAULT_GENERAL_SETTINGS[key]\n\n# Define premises and conclusions using raw strings for proper backslash handling\npremises2 = [r\"(\\exclude (P \\uniwedge Q) \\uniequiv (\\exclude P \\univee \\exclude Q))\"]\nconclusions2 = []\n\n# Create syntax, model constraints, and model structure\nsyntax2 = mc.syntactic.Syntax(premises2, conclusions2, operators)\nmodel_constraints2 = mc.model.ModelConstraints(settings, syntax2, semantics, proposition_class)\nmodel_structure2 = exclusion.ExclusionStructure(model_constraints2, settings)\n\n# Print the results\ntry:\n    model_structure2.print_all(settings, \"DeMorgan's Identity\", \"Exclusion Semantics\")\nexcept Exception as e:\n    print(f\"Error displaying model: {e}\")\n    # Check if 'expectation' key is missing\n    if 'expectation' not in settings:\n        print(\"Adding missing 'expectation' key to settings\")\n        settings['expectation'] = True\n        # Try again with the fixed settings\n        model_structure2.print_all(settings, \"DeMorgan's Identity\", \"Exclusion Semantics\")"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "These may seem initially opaque, so it is recommended to see the specific implementations of constraints in the `Semantics` object and `Proposition` object you have. Additionally note that any quantifiers in definitions are finite—i.e. we do not use the default quantifiers from 'z3'. This is because this is much faster for small state spaces. \n",
    "\n",
    "Now we define the model structure. This will be user-defined (?), but mostly just for printing; the bulk of it is defined in the `ModelDefaults` class of the `model.py` module of `model_checker`. We also need to feed in some settings; we can use the settings from above as default in case we don't want anything interesting. \n",
    "\n",
    "Defining this object automatically solves the constraints and finds a model. (i.e. this is where the Z3 magic happens) We can print the `z3` model—which is sometimes useful for debugging—if a model was found or the `z3` `unsat_core` (see here for more details: https://z3prover.github.io/api/html/ml/Z3.Solver.html) if no model was found. We can also print the model in a user-friendly way, which is what the last step does. \n",
    "\n",
    "There are many user-useful print methods defined in the model structure, both in the theory-specific object (entire point of defining this object) and the default (in the position mentioned in the second paragraph). It is recommended to look at those. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model_structure = exclusion.ExclusionStructure(model_constraints, settings)\n",
    "# NOTE: below not working because 'expectation' key not in settings\n",
    "# model_structure.print_model() # prints the z3 model or the unsat core, depending on if model found\n",
    "model_structure.print_all(settings, \"DeMorgan's\", \"Exclusion Semantics\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "No countermodels found, as desired! Now we will try a different theorem, for which we expect countermodels in the exclusion semantics. Namely, the propositional equivalence between the two sides of DeMorgan's tested above. The good thing is, we only need to redefined the `Syntax` object, `ModelConstraints` object, and the `ModelStructure` object—the semantics and proposition class are reusable from before, highlighting the convenient modularity of the `model_checker`! "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "premises2 = [\"(\\\\exclude (P \\\\uniwedge Q) \\\\uniequiv (\\\\exclude P \\\\univee \\\\exclude Q))\"]\n",
    "conclusions2 = []\n",
    "\n",
    "DEFAULT_GENERAL_SETTINGS = {\n",
    "        \"print_impossible\": False,\n",
    "        \"print_constraints\": False,\n",
    "        \"print_z3\": False,\n",
    "        \"save_output\": False,\n",
    "        \"maximize\": False,\n",
    "    }\n",
    "\n",
    "for key in DEFAULT_GENERAL_SETTINGS:\n",
    "    settings[key] = DEFAULT_GENERAL_SETTINGS[key]\n",
    "\n",
    "syntax2 = mc.syntactic.Syntax(premises2, conclusions2, operators)\n",
    "model_constraints2 = mc.model.ModelConstraints(settings, syntax2, semantics, proposition_class)\n",
    "model_structure2 = exclusion.ExclusionStructure(model_constraints2, settings)\n",
    "model_structure2.print_all(settings, \"DeMorgan's Identity\", \"Exclusion Semantics\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}