# OUTLINE

- intro (5 min)
  - motivation: standard methodology
  - hard, slow, error prone
  - difficult to scale the expressive power of the language
  - logos as unified language
  - TheoryLib
- programmatic semantics (10 min)
  - SMT solvers (Z3)
  - bitvectors as states
  - primitive sorts in Z3
  - model-checker to facilitate
    - translate into Z3 constraints
    - find a model if there is one
    - use model to interpret and print
  - can't survey all models (just finite ones below a certain size)
    - countermodels give certainty in invalidity
    - theoremhood is supported by ruling out models below a given N
    - higher N means more higher certainty in theoremhood
  - DEMO 1: IMPOSITION SEMANTICS
    - run examples
    - unit tests
- computational complexity as a theoretical virtue (10 min) -- MIGUEL
  - data structure that stores functions that depend on state space grows exponentially with N
    - computability becomes a new theoretical virtue
    - for reasons of speed (bigger data structures take more time), but also in the entire "higher N means higher certainty in theoremhood" convo: size of the model it handles also matters
  - where this matters: primitive functions
    - how Z3 stores functions (worst case: basically an array)
    - DEMO WITH -z FLAG
    - array with larger input _space_ has larger _space complexity_ (go over space complexity here)
    - larger _space_ complexity means longer runtime to fill that space up: slower programs
    - TL;DR cost of a primitive scales exponentially with arity
  - computational costs in action
    - imposition 10x slower than logos for N=4 for most theorems in the examples.py files
      - when talking about 0.1 vs 1 or even 0.01 vs 0.1 seconds, not too bad. For countermodels, low N often suffices
      - but, remember: more N good N. at N=5 many of the imposition theorems take more than 100 seconds. logos could do them in less (from 1 ish second to 70 ish seconds)
  - so if we are to use this tool for making theories, computability is now a virtue
  - compare with simplicity (kinda like intuitive computability for humans)
    - often no objective measure on simplicity. Not the case for computability: time is very easy, even before that space complexity
    - questions of computability with Z3 are also not always straightforward—sometimes some theorems go through easier than others for reasons not well understood to us, probably having to do with reasoning shortcuts (tactics and goals) Z3 takes—but overall it is a chartable space and arguably even in these areas more measurable than intuitive simplicity
  - DEMO MAXIMIZER FOR IMPOSITION SEMANTICS
- imposition defined (5 min)
  - maximal compatible parts
  - alternative worlds
  - semantics for counterfactuals
  - DEMO COMPARISON
- modality defined (5 min)
  - `\Box A := \top \boxright A` over `\Box A := \neg A \boxright \bot`
    - iterated modals don't force counterfactuals into the antecedent
    - intuitive reading: if anything were the case, A would be the case
  - imposition theory admits countermodels to this definition
    - many vacuous countermodels
    - but good logic
