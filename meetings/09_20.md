# NOTES

- The new modules look great! 
- true and false behavior cut to the chase?
- where should proposition class go?
  - probably ModelStructure?
  - should include the model constraints
  - should include the print methods
- solve in ModelSetup and return ModelStructure
- separate syntax from semantics
  - make it operator agnostic
  - should know which expressions are well-formed without semantics
  - define `find_op_and_args(string, parens_number=0, triggered=False)` algorithm:
    - if `triggered` and `parens_number=0`, then return
    - if first character is a left parentheses:
      - cut and store the first character in `left_arg`
      - set `parens_number =+ 1`
      - run `find_op_and_args(string, parens_number, true)`
    - if first character is a right parentheses:
      - cut and store the first character in `left_arg`
      - set `parens_number =- 1`
      - run `find_op_and_args(string, parens_number, triggered)`
    - else:
      - cut and store first character in `left_arg`
      - run `find_op_and_args(string, parens_number, triggered)`
  - define `prefix` algorithm:
    - `infix_sentence` takes one of three forms:
      - `(left_arg \op right_arg)` in the case of a binary operator
      - `\op single_arg` in the case of a unary operator
      - `\op` in the case of a zero-place operator
    - converting to prefix form is easy for the latter two forms
    - if the first form, then the algorithm proceeds by:
      - delete first left parentheses
      - if the next character is a space, delete and check the next character
      - if the next character is a parentheses, then set `left_arg, op, right_arg = find_op_and_args(infix_sentence)`
      - else:
        - store everything up to first `\` as `left_arg`
        - store the next word as `op`
        - store the remainder minus the final parentheses as `right_arg`
      - return `[op, prefix(left_arg), prefix(right_arg)]`
- make `null_constraints` default which can be turned off if the user specifies `contingent = true` or `null = true`
